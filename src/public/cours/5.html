<h4>Injection SQL</h4>
<p style="text-align: justify">Parmi les failles web, l’injection SQL est sûrement la plus connue.
    C’est aussi pour ça qu’il existe des méthodes simples pour s’en prémunir.</p>
<p style="text-align: justify">Rappelons brièvement ce qu’est une injection SQL :</p>
<p style="text-align: justify">L’attaque consiste à modifier une requête SQL en injectant des morceaux de code non filtrés, généralement par le biais d'un formulaire.
    Imaginons la requête SQL suivante encapsulée dans du PHP pour authentifier un membre sur un site web :</p>
<code>$req = $bdd->query("SELECT * FROM utilisateurs WHERE login='$login' AND password='$password'");</code>
<p style="text-align: justify">Les variables $login et $password proviennent directement du formulaire de connexion.
    Si un utilisateur s’amuse à remplir le champ login par « jean’ # » et à laisser le champ de mot de passe vide, la requête cherchera un compte qui a pour login jean.</p>

<code>&lt;?php
$req = $bdd->query("SELECT * FROM utilisateurs WHERE login='jean' # AND password=''");
// Qui sera interprété de la façon suivante
$req = $bdd->query("SELECT * FROM utilisateurs WHERE login='jean'");
    ?&gt;</code>

<p style="text-align: justify">Il sera donc très simple pour un utilisateur malveillant de s’authentifier avec n’importe quel compte !
    Voici d’autres utilisations d’injection SQL pour détourner la requête initiale :</p>

<ul>
    <li>Les conditions toujours vraies comme 1 = 1</li>
    <code>SELECT * FROM admin WHERE login='' OR '1'='1' AND pass='' OR '1'='1'</code>
    <li>Les liaisons entre les tables
    </li>
    <code>SELECT login, password FROM admin WHERE login='' UNION SELECT login, password from admin # ' and password='$password'
    </code>
    <li>Outfile
    </li>
    <code>SELECT login, password FROM admin WHERE login='' OR 'X'='X' INTO OUTFILE '../../www/file.txt' #' AND password='$password'";
    </code>
</ul>


<p style="text-align: justify">Les variables qui interviennent dans les requêtes SQL ne proviennent pas nécessairement de formulaire.
    Elles peuvent provenir de l’URL.
Ainsi toutes les variables qui interviennent dans les requêtes SQL et qui peuvent être modifiées par l’utilisateur doivent être vérifiées.
    Et pour cela il existe un moyen très simple : les requêtes préparées.</p>
<p style="text-align: justify">Les langages web qui sont mis à jour proposent les requêtes préparées.
    En PHP, la requête précédente s’écrira comme suit sous forme de requête préparée :</p>

<code>
// Requête SQL sécurisée
$req = $bdd->prepare("SELECT * FROM utilisateurs WHERE login= ? AND password= ?");
$req->execute(array($login, $password));
</code>

<p style="text-align: justify">Mais pourquoi les requêtes préparées empêchent-elles l’exécution de code malicieux ?</p>
<p style="text-align: justify">Une requête SQL peut être vue comme un programme et comme le montre la requête préparée précédente, la requête qui constitue le programme n’a aucune valeur de variables.
    La première requête permet à l’interpréteur SQL de prendre connaissance du programme. </p>
<p style="text-align: justify">La deuxième requête vient ensuite fournir les valeurs des variables mais elles restent séparées du programme SQL !
    L’interpréteur sait donc ce qu’il doit exécuter et le code malicieux ne sera pas exécuté.</p>
<p style="text-align: justify">Il est préférable de ne pas utiliser les fonctions de type mysql_real_escape_string() qui échappent les caractères spéciaux SQL en ajoutant un \ aux chaînes suivantes :
    NULL, \x00, \n, \r, \, ', " et \x1a. </p>
<p style="text-align: justify">En effet, ces fonctions ne permettent pas de se protéger de toutes les injections SQL et notamment des injections sur des variables de type numérique.
    Analysons l’exemple suivant :</p>
<code>
$id = $_POST['id'];
$requete = mysql_query("SELECT age FROM membres WHERE id=$id");
</code>

<p style="text-align: justify">
mysql_real_escape_string() ne servirait à rien ici.
</p>
<p style="text-align: justify">
En effet si un pirate veut injecter du code SQL, il n'aura pas besoin d'utiliser les quotes puisque la variable $id n'est pas entourée de quotes.
    Voici un exemple simple d'exploitation :</p>
<code>
2 UNION SELECT password FROM membres WHERE id=1
</code>
<p style="text-align: justify">
    Qui sera interprété de la manière suivante :</p>
<code>
SELECT age FROM membres WHERE id=2 UNION SELECT password FROM membres WHERE id=1
</code>
<p style="text-align: justify">
C’est pourquoi il est necessaire d’utiliser des requêtes préparées.
</p>