<h4>La CSRF</h4><p style="text-align: justify;">Explication</p><p style="text-align: justify;">La faille CSRF (&quot;Cross site request forgery&quot;) est tr&egrave;s souvent assimil&eacute;e &agrave; la XSS alors que ces deux failles sont diam&eacute;tralement oppos&eacute;es. Quand la XSS cherche &agrave; d&eacute;rober des informations personnelles de l&#39;utilisateur, la CSRF cherche &agrave; lui faire ex&eacute;cuter des actions &agrave; son insu directement sur son ordinateur. Dans le cours sur les failles XSS, on a vu comment le pirate utilisait la XSS pour voler les cookies d&rsquo;autres utilisateurs. Si un hacker d&eacute;cidait d&#39;utiliser la CSRF, il ferait ex&eacute;cuter des actions directement sur l&#39;ordinateur de la victime.</p><p style="text-align: justify;">Un petit exemple pour clarifier tout &ccedil;a :</p><p style="text-align: justify;">Je suis membre d&#39;un forum et il y a une personne que je veux bannir du forum. Je sais que pour supprimer un profil, l&#39;administrateur se rend sur l&#39;URL suivante&nbsp;:</p><p><code>www.monsite.com/index.php?profile=mon_ennemi&amp;action=supprimer</code></p><p><br></p><p style="text-align: justify;">&Eacute;videmment le script qui se trouve derri&egrave;re v&eacute;rifie que la personne qui se rend sur l&#39;URL est bien administrateur. Je dois donc trouver un moyen pour me rendre sur cette URL en &eacute;tant administrateur. Deux choix s&#39;offrent alors &agrave; moi.</p><p style="text-align: justify;">Soit j&#39;utilise une faille XSS pour subtiliser les cookies de l&#39;administrateur et me connecter ult&eacute;rieurement, tranquillement de chez moi.</p><p style="text-align: justify;">Soit j&#39;utilise une CSRF pour le rediriger vers cette page, et ainsi lui faire supprimer mon ennemi sans qu&#39;il ne le sache.</p><p style="text-align: justify;">Et cette faille peut &ecirc;tre appliqu&eacute;e &agrave; n&rsquo;importe quel site. Si vous &ecirc;tes connect&eacute; &agrave; votre compte Facebook, le hacker peut se servir d&#39;une CSRF pour vous faire aimer une page, publier un message, etc... Si les banques n&#39;&eacute;taient pas prot&eacute;g&eacute;es contre ce type d&#39;attaque, un hacker pourrait sans probl&egrave;me r&eacute;diger un script qui vous fait envoyer de l&#39;argent &agrave; quelqu&#39;un.</p><p style="text-align: justify;">Comme vous le voyez, il est compliqu&eacute; de se concentrer sur un seul exemple, &eacute;tant donn&eacute; que les applications de cette faille sont presque infinies. Et vous allez voir qu&#39;il est &eacute;galement compliqu&eacute; de s&#39;en prot&eacute;ger compl&egrave;tement.</p><h4>Comment s&#39;en prot&eacute;ger&nbsp;?</h4><h4>Authentification par jeton (token)</h4><p style="text-align: justify;">Comme je l&#39;ai dit pr&eacute;c&eacute;demment, il n&#39;existe malheureusement pas de protection parfaite contre la CSRF. La fa&ccedil;on la plus r&eacute;pandue &eacute;tant l&#39;utilisation d&#39;un jeton unique qui sera v&eacute;rifi&eacute; &agrave; chaque modification. Pour g&eacute;n&eacute;rer le token, utilisez une fonction de g&eacute;n&eacute;ration al&eacute;atoire de caract&egrave;res hexad&eacute;cimaux. En PHP, on proc&eacute;dera de la fa&ccedil;on suivante&nbsp;:</p><p><code>&lt;?php $token = bin2hex(mcrypt_create_iv(32, MCRYPT_DEV_URANDOM)); ?&gt;</code></p><p><br></p><p style="text-align: justify;">D&#39;apr&egrave;s la documentation PHP : mcrypt_create_iv() cr&eacute;e un IV (vecteur d&#39;initialisation) &agrave; partir d&#39;une source al&eacute;atoire.</p><p style="text-align: justify;">Le vecteur d&#39;initialisation est le seul moyen de fournir une initialisation de remplacement aux m&eacute;thodes d&#39;initialisation. Ce vecteur n&#39;a pas besoin d&#39;&ecirc;tre particuli&egrave;rement secret, m&ecirc;me si c&#39;est mieux. Vous pouvez l&#39;envoyer avec vos documents chiffr&eacute;s sans perdre en s&eacute;curit&eacute;. Voil&agrave; un exemple de formulaire prot&eacute;g&eacute; par token :</p><p><code>&nbsp;&lt;?php<br>&nbsp;// On d&eacute;marre la session en d&eacute;but de chaque page<br>&nbsp;session_start();<br>&nbsp;//On enregistre notre token<br>&nbsp;$token = bin2hex(mcrypt_create_iv(32, MCRYPT_DEV_URANDOM));<br>&nbsp;$_SESSION[&#39;token&#39;] = $token;<br>&nbsp;?&gt;<br><br>&nbsp;&lt;!DOCTYPE html&gt;<br>&nbsp;&lt;html&gt;<br>&nbsp;&lt;head&gt;<br></code></p><p class="tabulation"><code>&lt;meta charset=&quot;utf-8&quot;/&gt;</code></p><code>&nbsp;<p class="tabulation">&lt;title&gt;Mon Site&lt;/title&gt;</p>&nbsp;&lt;/head&gt;<br>&nbsp;&lt;body&gt;<br>&nbsp;&lt;form&gt;<br><p class="tabulation">&lt;!-- Pseudo de la personne &agrave; supprimer --&gt;</p>&nbsp;<p class="tabulation">&lt;input type=&quot;text&quot; name=&quot;pseudo&quot; id=&quot;pseudo&quot; /&gt;</p>&nbsp;<p class="tabulation">&lt;input type=&quot;submit&quot; value=&quot;valider&quot; /&gt;</p>&nbsp;<p class="tabulation">&lt;!-- Notre token de v&eacute;rification, bien cach&eacute; --&gt;</p>&nbsp;<p class="tabulation">&lt;input type=&quot;hidden&quot; name=&quot;token&quot; id=&quot;token&quot; value=&quot;&lt;?php echo $token; ?&gt;&quot; /&gt;</p>&nbsp;&lt;/form&gt;<br>&nbsp;&lt;/body&gt;<br>&nbsp;&lt;/html&gt;<br></code><p></p><p style="text-align: justify;">Si on voulait bien faire les choses, on mettrait en place une page PHP qui se chargerait de g&eacute;n&eacute;rer le token s&rsquo;il n&#39;existe pas d&eacute;j&agrave;.
Voil&agrave;, on a plus qu&#39;&agrave; v&eacute;rifier lors du traitement de la demande :</p><p><code>&nbsp;&lt;?php<br>&nbsp;session_start();<br>&nbsp;//On v&eacute;rifie que tous les jetons sont l&agrave;<br>&nbsp;if (isset($_SESSION[&#39;token&#39;]) <br>AND isset($_POST[&#39;token&#39;])<br>&nbsp;AND !empty($_SESSION[&#39;token&#39;])<br>&nbsp;AND !empty($_POST[&#39;token&#39;])) {<br></code></p><p class="tabulation"><code>// On v&eacute;rifie que les deux correspondent</code></p><code>&nbsp;<p class="tabulation">if ($_SESSION[&#39;token&#39;] == $_POST[&#39;token&#39;]) {</p>&nbsp;<p class="tabulation">// V&eacute;rification termin&eacute;e</p>&nbsp;<p class="tabulation">// On peut supprimer l&#39;utilisateur</p>&nbsp;<p class="tabulation">}</p>&nbsp;} <br>&nbsp;else {&nbsp;<p class="tabulation">// Les token ne correspondent pas</p>&nbsp;<p class="tabulation">// On ne supprime pas</p>&nbsp;<p class="tabulation">echo &quot;Erreur de v&eacute;rification&quot;;</p>&nbsp;} ?&gt;&nbsp;</code><p></p><p><br></p><p style="text-align: justify;">Si on voulait faire encore mieux, on pourrait rajouter une variable de session qui enregistre l&#39;heure de la cr&eacute;ation du token. On met ensuite en place un syst&egrave;me qui v&eacute;rifie que le token n&#39;a pas &eacute;t&eacute; cr&eacute;&eacute; il y a trop longtemps. En g&eacute;n&eacute;ral le d&eacute;lai d&#39;expiration des token est de 10 minutes. Il est &eacute;galement possible d&#39;utiliser les jetons hors formulaire en les faisant passer dans l&#39;URL.</p><p><code>www.monsite.com/index.php?profile=mon_ennemi&amp;action=supprimer&amp;token22f2f68d45fe0baea8d064bdd4604391ba95752b4df6c85f478c56207addebb9</code></p><p><br></p><p style="text-align: justify;">Bon voil&agrave; en gros ce type de protection devrait en d&eacute;courager plus d&#39;un, et on pourrait s&#39;arr&ecirc;ter l&agrave;. Mais il existe d&#39;autres petites techniques qui compl&egrave;tent bien l&#39;utilisation d&#39;un token.</p><h5>Demande de confirmation</h5><p style="text-align: justify;">Bon pour cette technique pas besoin d&#39;&eacute;piloguer. Il s&#39;agit simplement de demander &agrave; l&#39;administrateur de confirmer l&#39;action avec un pop-up de confirmation ou m&ecirc;me mieux, une confirmation par mot de passe. Ainsi, on r&eacute;duit encore plus le risque de suppression involontaire.</p><h5>Un captcha</h5><p style="text-align: justify;">Une autre technique consiste &agrave; demander &agrave; l&#39;administrateur de valider l&#39;action en remplissant un captcha. C&#39;est tout b&ecirc;te et tr&egrave;s efficace, mais pas tr&egrave;s adapt&eacute; si l&#39;action est r&eacute;p&eacute;titive...</p><h5>V&eacute;rifier le Referer Header (Controvers&eacute;)</h5><p style="text-align: justify;">Cette protection est tr&egrave;s connue et recommand&eacute;e par de nombreux sites. Il est vrai qu&#39;il est toujours bon d&#39;ajouter une v&eacute;rification compl&eacute;mentaire, mais vous devez savoir qu&#39;il est possible de contourner cette v&eacute;rification en modifiant le HTTP_REFERER.</p><p style="text-align: justify;">Le terme anglais utilis&eacute; pour &quot;modifier&quot; est &quot;spoof&quot;. C&#39;est un terme tr&egrave;s utilis&eacute;, particuli&egrave;rement en s&eacute;curit&eacute; informatique, je vous conseille donc vivement de le retenir.</p><p style="text-align: justify;">Dans notre cas &quot;modifier le HTTP_REFERER&quot; se traduit par &quot;spoof the referer header&quot;. Ainsi vous pouvez l&#39;utiliser comme protection suppl&eacute;mentaire, mais n&#39;ayez pas trop confiance en cette technique. Voil&agrave; malgr&eacute; tout un petit code :</p><p><code>&nbsp;&lt;?php<br>&nbsp;if($_SERVER[&#39;HTTP_REFERER&#39;] == &#39;http://www.monsite.com/formulaire_suppression.php&#39;) {<br></code></p><p class="tabulation"><code>// On a v&eacute;rifi&eacute; la provenance de la requ&ecirc;te</code></p><code>&nbsp;<p class="tabulation">// On passe &agrave; la suite</p>&nbsp;}<br>&nbsp;?&gt;&nbsp;</code><p></p><p style="text-align: justify;">Donc si on reprend notre formulaire de tout &agrave; l&#39;heure :</p><p><code>&nbsp;&lt;?php<br>&nbsp;session_start();<br>&nbsp;//On v&eacute;rifie que tous les jetons sont l&agrave;<br>&nbsp;if (isset($_SESSION[&#39;token&#39;]) <br>AND isset($_POST[&#39;token&#39;]) <br>AND !empty($_SESSION[&#39;token&#39;]) <br>AND !empty($_POST[&#39;token&#39;]))<br>&nbsp;{<br></code></p><p class="tabulation"><code>// On v&eacute;rifie que les deux correspondent</code></p><code>&nbsp;<p class="tabulation">if ($_SESSION[&#39;token&#39;] == $_POST[&#39;token&#39;]) {</p>&nbsp;<p class="tabulation2">// On v&eacute;rifie que la requ&ecirc;te vient bien du formulaire</p>&nbsp;<p class="tabulation2">if ($_SERVER[&#39;HTTP_REFERER&#39;] == &#39;http://www.monsite.com/formulaire_suppression.php&#39;) {</p>&nbsp;<p class="tabulation2">// On a v&eacute;rifi&eacute; la provenance de la requ&ecirc;te</p>&nbsp;<p class="tabulation2">// On peut supprimer</p>&nbsp;<p class="tabulation2">}</p>&nbsp;<p class="tabulation2">// La requ&ecirc;te vient d&#39;autre part, on bloque</p>&nbsp;<p class="tabulation2">else {</p>&nbsp;<p class="tabulation2">echo &quot;La requ&ecirc;te ne provient pas du formulaire&quot;;</p>&nbsp;<p class="tabulation2">}</p>&nbsp;<p class="tabulation">}</p>&nbsp;} <br>&nbsp;else {<br><p class="tabulation">// Les token ne correspondent pas</p>&nbsp;<p class="tabulation">// On ne supprime pas</p>&nbsp;<p class="tabulation">echo &quot;Erreur de v&eacute;rification&quot;;</p>&nbsp;} ?&gt;&nbsp;</code><p></p><p><br></p><h5>Id&eacute;es re&ccedil;ues sur la protection</h5><p style="text-align: justify;">Beaucoup de gens rivalisent d&#39;ing&eacute;niosit&eacute; pour contrer cette faille. Mais bien souvent, les petites bidouilles ne prot&egrave;gent rien du tout. Voil&agrave; ce qui, contrairement aux id&eacute;es re&ccedil;ues, ne vous prot&egrave;gera pas :</p><ul><li>V&eacute;rification par cookie ultra secret</li><li>Oublier la m&eacute;thode GET et n&#39;utiliser que POST</li><li>Ajouter plein d&#39;&eacute;tapes</li><li>Utiliser de l&#39;URL rewriting</li></ul><p>R&eacute;f&eacute;rences :</p><p><a href="https://openclassrooms.com/fr/courses/2091901-protegez-vous-efficacement-contre-les-failles-web/2863569-la-csrf">https://openclassrooms.com/fr/courses/2091901-protegez-vous-efficacement-contre-les-failles-web/2863569-la-csrf</a></p>